[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data Visualization for Regression Monkeys",
    "section": "",
    "text": "Welcome\nこのQuarto Bookは以下のシリーズと連動して運用されています:",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Data Visualization for Regression Monkeys",
    "section": "References",
    "text": "References\n\n\nKnaflic, C. N. (2016), Storytelling\nwith data: A data visualization guide for business\nprofessionals, O’Reilly Media.\n\n\nYau, N. (2013), Data\npoints: Visualization that means something, Indianapolis, Ind.\n: John Wiley.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "posts/introduction.html",
    "href": "posts/introduction.html",
    "title": "Introduction",
    "section": "",
    "text": "良い可視化とは?\n良いデータ可視化は，統計分析と可視化デザインの２つの能力に基づいています．\n両方のスキルを適切に組み合わせることによって，データ探索とstory-tellingが結びついて，データの理解を目的とする科学的なコミュニケーションとなります．\n▶  Dataとはなにか？\nDataとは，スプレッドシートやカンマ区切りのレコードの集合といったコンピュター上での存在形式を指すのではなく，一義的には「世界の断面を記録したもの」です．\n▶  Rules vs Suggestions\nbar chartなりscatter plotなり，読み手がデータについて正確な解釈をすることができる可視化でなければならない，というのはデータ可視化のルールの１つです． 一方，axisのスケールなどは科学分野ではScientific Notation(例: \\(-1.602\\times 10^{-19}\\))を用いるべきなど，コミュニケーションの場面に応じて推奨が変わってきます．\n「余分な情報は削ぎ落とせ」と上司からコメントをもらったとしても，なにが余分な情報なのかは場面によって異なります．そのため，なにがRulesでなにがSuggestionなのかを区別する習慣が重要になります．",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "posts/introduction.html#良い可視化とは",
    "href": "posts/introduction.html#良い可視化とは",
    "title": "Introduction",
    "section": "",
    "text": "Definition 1 : 可視化 \nデータの構造・傾向・異常などを人が視覚的に理解できる形に変換する工程のことを可視化と呼ぶ．\n\n\n\n\n統計分析能力がない可視化デザインは，単なる様式美の提供にとどまり\n可視化デザイン能力が伴わない統計分析は単なる分析，データ探索にとなります\n\n\n\n\n\n\n\n\n可視化パッケージとstory-tellingの違い\nデータを用いたstory-tellingという活動の中の一つの工程として「データの構造やパターンを見やすくする」可視化が存在します．その可視化工程の便利ツールとしてmatplotlib, plotly, ggplot といった可視化パッケージが存在します． 可視化パッケージは可視化手法に関する文法(grammer)がユーザーフレンドリーな形で実装で実装されており，それらを使いこなすことで自分が伝えたい内容を上手く可視化オブジェクト(scatter plot, line plot, heatmap, etc.,)として出力することができます．\n一方，可視化パッケージを利用するにあたって，以下のポイントを常に忘れないようにしましょう\n\n可視化パッケージを使って出力されたものは，あくまでユーザーが指定したものに対応したオブジェクトであって，それ自体がデータを用いたstory-tellingになるわけではない\n可視化パッケージを使いこなしたとしても，その可視化オブジェクトスペース（表現幅）は可視化パッケージごとに規程されてしまうため，ユーザーが描きたい可視化オブジェクトは必ずしも描けるとは限らない\n\n ▶  可視化パッケージオブジェクト表現空間の制限\nたとえば seaborn でヒストグラムを描きたいと思ったとき，指定できるオプションや見た目は，seabornが提供している機能に限定されます． ユーザー操作に応じて可視化を変化させたい（インタラクティブ）場合，seabornだけでは不可能で，plotlyなど別パッケージの利用などを検討する必要が有ります．",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "posts/eda-setup/chapter-header.html",
    "href": "posts/eda-setup/chapter-header.html",
    "title": "データ可視化の20 Rules",
    "section": "",
    "text": "Rules\n\n\n\n\nSVGやEPSなどのvector graphicsを利用すること\n読みやすいフォントを使用すること\nごちゃごちゃした凡例(legend)は害悪．最低限，legendがデータポイントを隠してしまう事態は避けること\nAxes(軸)には適切なラベルをつけること\n\n\n\n\nRule 1: SVGやEPSなどのvector graphicsを利用すること\n\nvector graphicsは拡大しても鮮明さを保ち，ぼやけることがありません\nJPEG、BMP、PNGファイルは拡大すると画像がぼやけたり，非常に高解像度で保存した場合にはファイルサイズが極めて大きくなったりしてしまう\nPlotlyにてsvg形式でオブジェクトを保存する場合は kaleido が必要\n\n\n\nRule 2: 読みやすいフォントを使用すること\n\n日本語対応サンセリフ体として，Meiryo, M+ 1p, IPAexGothic があるので，これらのいずれかを使用すること\nfont typeだけでなく，font sizeも重要な要素．つぶれて読めなくなってしまう状況を回避すること\n\n\n\nRule 3: ごちゃごちゃした凡例(legend)は害悪\n\n凡例の乱れは精神の乱れ\n可能であれば，凡例を使わずにプロットの要素に直接ラベルを付ける\n最低限，凡例がプロットされたデータを隠さないように配置すること\nsequential dataであるならば，legendの順番は降順(highest to lowest)に並んでいること",
    "crumbs": [
      "データ可視化の20 Rules"
    ]
  },
  {
    "objectID": "posts/eda-setup/font-setup.html",
    "href": "posts/eda-setup/font-setup.html",
    "title": "1  Meiryo fontのセットアップ",
    "section": "",
    "text": "Linux環境でのMeiryo Font設定\nLinux OSの場合，.local/share/fonts以下に以下のMeiryoフォントをインストールします．\n環境要件\n手順",
    "crumbs": [
      "データ可視化の20 Rules",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Meiryo fontのセットアップ</span>"
    ]
  },
  {
    "objectID": "posts/eda-setup/font-setup.html#linux環境でのmeiryo-font設定",
    "href": "posts/eda-setup/font-setup.html#linux環境でのmeiryo-font設定",
    "title": "1  Meiryo fontのセットアップ",
    "section": "",
    "text": "Fonts\nFile\nExplanation\n\n\n\n\nMeiryo\nmeiryo.ttc\nMeiryo UI Regular, Meiryo UI Italic, Meiryo Regular, Meiryo Italic\n\n\n\nmeiryob.ttc\nMeiryo UI Bold, Meiryo UI Bold Italic, Meiryo Bold, Meiryo Bold Italic\n\n\n\n\n\n\nLinux operating system(Ubuntuを含む)\nfc-cache コマンド\n\nMacOsで実行する場合は, brew install ricty を実行することでfc-cache コマンドが利用可能になります\n\n\n\n# download repository\ngit clone https://github.com/yourusername/ManualFontInstaller.git\ncd ManualFontInstaller\n\n# Run script\n./install_fonts.sh",
    "crumbs": [
      "データ可視化の20 Rules",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Meiryo fontのセットアップ</span>"
    ]
  },
  {
    "objectID": "posts/eda-setup/font-setup.html#meiryoフォントを用いた可視化",
    "href": "posts/eda-setup/font-setup.html#meiryoフォントを用いた可視化",
    "title": "1  Meiryo fontのセットアップ",
    "section": "Meiryoフォントを用いた可視化",
    "text": "Meiryoフォントを用いた可視化\n\nPlotly\nimport plotly.express as px\n\nfig = px.scatter(x=[1, 2, 3], y=[4, 5, 6], title=\"サンプルグラフ\")\n\n# X軸ラベルの追加\nfig.update_layout(\n    xaxis_title=\"時間（秒）\",  # ← ここがX軸ラベル\n    font=dict(family=\"Meiryo\")\n)\n\nfig.show()\n\n\nMatplotlib\nimport matplotlib.pyplot as plt\n\nplt.rcParams[\"font.family\"] = \"Meiryo\"\n\nx = [1, 2, 3]\ny = [4, 5, 6]\n\nplt.plot(x, y, marker=\"o\")\nplt.title(\"サンプルグラフ\")\nplt.xlabel(\"時間（秒）\")  # ← ここがX軸ラベル\nplt.ylabel(\"値\")\n\nplt.show()",
    "crumbs": [
      "データ可視化の20 Rules",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Meiryo fontのセットアップ</span>"
    ]
  },
  {
    "objectID": "posts/eda-setup/font-setup.html#sources",
    "href": "posts/eda-setup/font-setup.html#sources",
    "title": "1  Meiryo fontのセットアップ",
    "section": "Sources",
    "text": "Sources\n\nRyoNakagami &gt; ManualFontInstaller",
    "crumbs": [
      "データ可視化の20 Rules",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Meiryo fontのセットアップ</span>"
    ]
  },
  {
    "objectID": "posts/visualization-components/chapter-header.html",
    "href": "posts/visualization-components/chapter-header.html",
    "title": "可視化オブジェクトのComponents",
    "section": "",
    "text": "可視化オブジェクトと可視化コンポーネント\n可視化は単なる「グラフ」や「図」ではなく，\nといった様々なコンポーネントの組み合わせによって成り立っています．また，理解しやすい可視化の文脈において，これらコンポーネントはそれぞれの役割を持っています\nこれらコンポーネントについての選択の積み重ねが，最終的な可視化オブジェクトの決定に繋がります．",
    "crumbs": [
      "可視化オブジェクトのComponents"
    ]
  },
  {
    "objectID": "posts/visualization-components/chapter-header.html#可視化オブジェクトと可視化コンポーネント",
    "href": "posts/visualization-components/chapter-header.html#可視化オブジェクトと可視化コンポーネント",
    "title": "可視化オブジェクトのComponents",
    "section": "",
    "text": "Axis\nLegends\nLabels\nFonts\n\n\n\n\n\n\nComponents\n役割\n\n\n\n\nAxis\n軸範囲や単位、スケールの情報を伝える．\n\n\nLegends\nデータグループや要素の分類を伝える．視認性に影響．\n\n\nLabels\nデータポイントの情報を伝える．\n\n\nFonts\n可視化全体のトーンと読みやすさに影響．\n\n\n\n\n\n\n\n\n\n\n\nREMARKS\n\n\n\n\n\\[\n\\text{データ可視化} = \\text{コンポーネント設計} \\times \\text{データ理解} \\nonumber\n\\]\n\n\nデータだけでなく，「どう見せるか」の設計が可視化の質を決める\n「どう見せるか」の設計の適切さは，コンポーネントの役割と使い方を理解に依存する",
    "crumbs": [
      "可視化オブジェクトのComponents"
    ]
  },
  {
    "objectID": "posts/visualization-components/Axes.html",
    "href": "posts/visualization-components/Axes.html",
    "title": "2  Axes",
    "section": "",
    "text": "Axesとは？",
    "crumbs": [
      "可視化オブジェクトのComponents",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Axes</span>"
    ]
  },
  {
    "objectID": "posts/visualization-components/Axes.html#axesとは",
    "href": "posts/visualization-components/Axes.html#axesとは",
    "title": "2  Axes",
    "section": "",
    "text": "Definition 2.1 Axes\n\nAxesとは，可視化オブジェクト内のデータポイントと数値的な意味を結びつけるための参照軸のこと\nAxesがあることで，「このデータポイントは何の値を表しているか」「他のポイントと比べてどれくらい大きいか/小さいか」といった情報を読み取ることができる\n\n\n\nAxes Title\n\n\n\n\n\n\nRules\n\n\n\n\n目盛（tick marks）の単位を示すこと\n\n\n\n下記の例では，Bad Exampleのy-axisでは「平均気温」の単位が記載されていません．日本では一般的に，摂氏がもしいられるので単位がなくても理解できるかもしれませんが，「℃」をy-axisに付与して目盛りの意味の解釈を容易にすることが読み手に対する配慮となります．\n\nCode\nimport pandas as pd\n\n# ----------------------------\n## 気象データdata preprocess\n# ----------------------------\n\n\ndef join_multilevel_col(col):\n    level0, level1, level2 = col\n    if \"Unnamed:\" in level2:\n        level2 = \"\"\n    if level2:\n        return (level0, f\"{level1}_{level2}\")\n    else:\n        return (level0, level1)\n\n\n# CSV読み込み（3行ヘッダー）\ndf = pd.read_csv(\"../data/monthly-average-temp-2024.csv\", header=[0, 1, 2])\n\n# '年月'のカラム名タプルが以下のようになっている前提\nidx_col = (\"Unnamed: 0_level_0\", \"年月\", \"Unnamed: 0_level_2\")\n\n# インデックスに設定\ndf.set_index(idx_col, inplace=True)\n\n# インデックス名をわかりやすく変更（任意）\ndf.index.name = \"年月\"\ndf.columns = pd.Index([join_multilevel_col(col) for col in df.columns])\ndf = df.stack(level=0, future_stack=True).reset_index()\n\nrename_dict = {\n    \"年月\": \"YearMonth\",\n    \"level_1\": \"City\",\n    \"平均気温(℃)\": \"average_temp\",\n    \"平均気温(℃)_品質情報\": \"average_temp_QualityInfo\",\n    \"平均気温(℃)_均質番号\": \"average_temp_KinshitsuNumber\",\n    \"降水量の合計(mm)\": \"total_precipitation_mm\",\n    \"降水量の合計(mm)_品質情報\": \"total_precipitation_mm_QualityInfo\",\n    \"降水量の合計(mm)_均質番号\": \"total_precipitation_mm_KinshitsuNumber\",\n    \"降水量の合計(mm)_現象なし情報\": \"total_precipitation_mm_NoPhenomenonInfo\",\n}\n\ndf = df.rename(columns=rename_dict)\n\n# data type\ndf[\"YearMonth\"] = pd.to_datetime(df[\"YearMonth\"], format=\"%Y/%m\")\n\n# ----------------------------\n## plot\n# ----------------------------\nimport plotly.express as px\n\nokabe_ito_palette = [\n    \"#E69F00\",  # orange\n    \"#56B4E9\",  # sky blue\n    \"#009E73\",  # bluish green\n    \"#F0E442\",  # yellow\n    \"#0072B2\",  # blue\n    \"#D55E00\",  # vermillion\n    \"#CC79A7\",  # reddish purple\n    \"#000000\",  # black\n]\n\n# 1. sort\ncity_order = (\n    df.groupby(\"City\")[\"average_temp\"].max().sort_values(ascending=False).index.tolist()\n)\n\n# 2. Set categorical order for 'City'\ndf[\"City\"] = pd.Categorical(df[\"City\"], categories=city_order, ordered=True)\n\ndf = df.sort_values(by=[\"City\", \"YearMonth\"]).reset_index(drop=True)\n\n# ----------------------------\n## Bad Example\n# ----------------------------\nfig = px.line(\n    df,\n    x=\"YearMonth\",\n    y=\"average_temp\",\n    color=\"City\",\n    color_discrete_sequence=okabe_ito_palette,\n    template=\"ggplot2\",\n    labels={\"City\": \"観測都市\"},\n)\n\n# Change axis titles\nfig.update_layout(\n    title=dict(\n        text=\"月別平均気温の推移（都市別） - Bad Example\",\n        x=0.075,\n        xanchor=\"left\",\n        y=0.95,\n        yanchor=\"top\",\n        font=dict(size=20),\n    ),\n    margin=dict(t=80),\n    xaxis_title=\"年月\",\n    yaxis_title=\"平均気温\",\n    xaxis=dict(tickformat=\"%Y-%m\"),\n    width=640,  # (px)\n    height=400,\n    legend=dict(\n        orientation=\"h\",  # horizontal layout\n        yanchor=\"bottom\",\n        y=1.02,  # slightly above the plot\n        xanchor=\"center\",\n        x=0.5,  # center-align\n    ),\n)\n\n\nfig.show()\n\n\n# ----------------------------\n## Better Example\n# ----------------------------\nfig = px.line(\n    df,\n    x=\"YearMonth\",\n    y=\"average_temp\",\n    color=\"City\",\n    color_discrete_sequence=okabe_ito_palette,\n    template=\"ggplot2\",\n    labels={\"City\": \"観測都市\"},\n)\n\n# Change axis titles\nfig.update_layout(\n    title=dict(\n        text=\"月別平均気温の推移（都市別） - Better Example\",\n        x=0.075,\n        xanchor=\"left\",\n        y=0.95,\n        yanchor=\"top\",\n        font=dict(size=20),\n    ),\n    margin=dict(t=80, b=40),\n    xaxis_title=\"年月\",\n    yaxis_title=\"平均気温 [°C]\",\n    xaxis=dict(tickformat=\"%Y-%m\"),\n    width=640,  # (px)\n    height=400,\n    legend=dict(\n        orientation=\"h\",  # horizontal layout\n        yanchor=\"bottom\",\n        y=1.02,  # slightly above the plot\n        xanchor=\"center\",\n        x=0.5,  # center-align\n    ),\n)\n\nfig.add_annotation(\n    text=\"&lt;a href='https://www.data.jma.go.jp/risk/obsdl/index.php' target='_blank' style='color:gray;'&gt;出所: 気象庁 &gt; 過去の気象データより作成&lt;/a&gt;\",\n    xref=\"paper\",\n    yref=\"paper\",\n    x=0,\n    y=-0.2,\n    showarrow=False,\n    font=dict(size=12),\n    align=\"left\"\n)\n\n\nfig.show()\n\n\n\n\n                                                \n\n\n\n\n                                                \n\n\n\n\n\nTick Marks(目盛り)\n\n\n\n\n\n\nRules\n\n\n\n\n軸上に要素のラベルや目盛りを過剰に配置しない\nラベル付きの目盛りの間隔が常に一定となるようにする\n\n\n\n適切な目盛りラベルの間隔は，可視化で伝えたいストーリー/キーメッセージに依存するのでケースバイケースで判断する必要があります．以下の例は，Googleの 株価の長期的なトレンドを示した時系列plotを用いて，軸ラベル間隔の違いによる可視性への影響を比較しています．この可視化の目的を\n\n長期的なトレンドや大まかな動きを示したい\n四半期ベースでの周期性を示したい\n\nとすると，Bad Exampleのような「月次」目盛りは，不必要にラベルが混雑してしまい，視認性が落ちてしまっています．一方，Better Exampleは目盛りラベルを四半期にフォーカスしているので\n\n視覚的にすっきり\n全体の動きやトレンドが見やすくなっている\n\nというメリットがあります．ただし，四半期目盛りでは月単位の詳細な変化が省略されるため，「特定の月中旬に起きた急騰・急落」のようなイベントは目盛りからは把握しにくくなります．このような場合は「Direct Labelling」や「hover data」などを活用することで，視認性と情報密度のバランスを保ちつつ，ユーザーの関心に応じて詳細を掘り下げるのが良いです．\n\n\nCode\nimport numpy as np\nimport plotly.express as px\n\ndf = px.data.stocks()\nfig = px.line(\n    df,\n    x=\"date\",\n    y=\"GOOG\",\n    color_discrete_sequence=okabe_ito_palette,\n    template=\"ggplot2\",\n)\n\n# Set x-axis to show daily ticks\nfig.update_layout(\n    title=dict(\n        text=\"Google Stock closing prices -- Bad Example\",\n        x=0.075,\n        xanchor=\"left\",\n        y=0.95,\n        yanchor=\"top\",\n        font=dict(size=20),\n    ),\n    margin=dict(t=60),\n    xaxis=dict(\n        dtick=\"M1\",  # daily ticks\n        tickformat=\"%Y-%m-%d\",  # display format\n        tickangle=45,  # optional: tilt labels for readability\n    ),\n    yaxis_title=\"Closing Price[USD]\",\n    width=720,  # (px)\n    height=450,\n    legend=dict(\n        orientation=\"h\",  # horizontal layout\n        yanchor=\"bottom\",\n        y=1.02,  # slightly above the plot\n        xanchor=\"center\",\n        x=0.5,  # center-align\n    ),\n)\n\nfig.show()\n\n\n# Extract available monthly dates (for tickvals)\nall_dates = pd.to_datetime(df[\"date\"].unique())\n\n# Extract year & month\ndf[\"month\"] = all_dates.to_period(\"M\")\nmonth_dates = pd.to_datetime(df.groupby(\"month\")[\"date\"].min().reset_index(drop=True))\n\ntick_labels = np.where(\n    month_dates.dt.month.isin([1, 4, 7, 10]),\n    month_dates.dt.to_period(\"Q\").astype(str),\n    \"\",\n)\n\nfig = px.line(\n    df,\n    x=\"date\",\n    y=\"GOOG\",\n    hover_data={\n        \"date\": False,\n        \"traded-date\": df[\"date\"].values,\n        \"GOOG\": \":.2f\",  # format to 2 decimals\n        # add other columns if needed\n    },\n    color_discrete_sequence=okabe_ito_palette,\n    template=\"ggplot2\",\n)\n\n\n# Set x-axis to show daily ticks\nfig.update_layout(\n    title=dict(\n        text=\"Google Stock closing prices -- Better Example\",\n        x=0.075,\n        xanchor=\"left\",\n        y=0.95,\n        yanchor=\"top\",\n        font=dict(size=20),\n    ),\n    margin=dict(t=60, b=80),\n    xaxis=dict(\n        dtick=\"M1\",  # monthly tick marks\n        showgrid=True,\n        tickvals=month_dates,  # show labels only quarterly\n        ticktext=tick_labels,  # what the labels say\n        tickformat=\"\",  # prevent default format override\n        tickangle=0,\n        ticks=\"outside\",  # show tick marks\n    ),\n    xaxis_title=\"取引日\",\n    yaxis_title=\"Closing Price[USD]\",\n    width=720,  # (px)\n    height=450,\n    legend=dict(\n        orientation=\"h\",  # horizontal layout\n        yanchor=\"bottom\",\n        y=1.02,  # slightly above the plot\n        xanchor=\"center\",\n        x=0.5,  # center-align\n    ),\n)\n\n# Use hovertemplate for formatting and hiding 'date' column\nfig.update_traces(\n    hovertemplate=(\n        \"取引日: %{customdata[0]}&lt;br&gt;\" + \"GOOG: %{y:.2f}&lt;br&gt;\" + \"&lt;extra&gt;&lt;/extra&gt;\"\n    )\n)\n\n# レイアウト下部にデータソース注釈を追加\nfig.add_annotation(\n    text=\"Data source: Yahoo Finance (via plotly.data.stocks)\",\n    xref=\"paper\",\n    yref=\"paper\",\n    x=0,\n    y=-0.2,  # x=0: 左寄せ, y=-0.15: グラフの下\n    showarrow=False,\n    font=dict(size=12, color=\"gray\"),\n    align=\"left\",\n)\n\n\nfig.show()",
    "crumbs": [
      "可視化オブジェクトのComponents",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Axes</span>"
    ]
  },
  {
    "objectID": "posts/visualization-components/legends.html",
    "href": "posts/visualization-components/legends.html",
    "title": "3  Legends(凡例)",
    "section": "",
    "text": "Legendsとは？",
    "crumbs": [
      "可視化オブジェクトのComponents",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Legends(凡例)</span>"
    ]
  },
  {
    "objectID": "posts/visualization-components/legends.html#legendsとは",
    "href": "posts/visualization-components/legends.html#legendsとは",
    "title": "3  Legends(凡例)",
    "section": "",
    "text": "Definition 3.1 Legends\n\n可視化要素の意味を示すために用いられるコンポーネント\nLabelsと異なり，図の外側にまとめて表示される\nLegends項目を示すマーカーと対応するラベルのセットによって構成される\n\n\n\n凡例の位置\n\n\n凡例の順番\n\n\n\n\n\n\nRules\n\n\n\n\nSequential dataについてのLegendsは必ず降順(higest to lowest)にすること\ncategorical classについても可視化オブジェクトの目線の順番と整合的な表示順番にすること\n\n\n\ncategorical classにおける凡例の順番\n\nCode\nimport yfinance as yf\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# okabe_ito_colorsの取得\nokabe_ito_colors = [\n    \"#000000\", \"#E69F00\", \"#56B4E9\", \"#009E73\",\n    \"#F0E442\", \"#0072B2\", \"#D55E00\", \"#CC79A7\"\n]\n\n# 銘柄のシンボル（ティッカー）\nsymbols = {\"Meta\": \"META\", \"Alphabet\": \"GOOGL\", \"Microsoft\": \"MSFT\", \"Apple\": \"AAPL\"}\n\n# 期間設定\nstart_date = \"2020-01-01\"\nend_date = \"2024-01-01\"\n\n# --------------------------------------------------------\n# Bad plot\n# --------------------------------------------------------\n# 株価データの取得とプロット\nplt.figure(figsize=(12, 8))\n\n# (index, (key, value))形式\nfor c_index, (name, ticker) in enumerate(symbols.items()):\n    data = yf.download(ticker, start=start_date, end=end_date, auto_adjust=True,  progress=False)\n    data = data / data.iloc[0] * 100\n    plt.plot(data[\"Close\"], label=name, color=okabe_ito_colors[c_index])\n\n# remove box\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\nplt.title(\"Stock Prices (2023)\")\nplt.xlabel(\"Date\")\nplt.ylabel(\"Normalized Close Price (Base=100)\")\nplt.legend()\nplt.grid(axis='y', alpha=0.5)\nplt.tight_layout()\nplt.show()\n\n# --------------------------------------------------------\n# Better plot\n# --------------------------------------------------------\n# 空のDataFrameを用意\ndf_all = pd.DataFrame()\n\nfor name, ticker in symbols.items():\n    # データ取得\n    data = yf.download(ticker, start=start_date, end=end_date, auto_adjust=True, progress=False)\n    \n    # 終値を正規化（初日の価格を100に）\n    normalized = data['Close'] / data['Close'].iloc[0] * 100\n    \n    # 列名に銘柄名を設定してDataFrameに格納\n    df_all[name] = normalized\n\n# 最新日のデータ取得（インデックスは日付）\nlast_day = df_all.index[-1]\n\n# 最新日の値を降順でソート（大きい順）\nsorted_columns = df_all.loc[last_day].sort_values(ascending=False).index\n\n# 並び替えた順でプロット\nplt.figure(figsize=(12, 8))\nfor c_index, col in enumerate(sorted_columns):\n    plt.plot(df_all.index, df_all[col], label=col, color=okabe_ito_colors[c_index])\n\n# remove box\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\nplt.title(\"Normalized Stock Prices(Base=100 at 2020-01)\", fontsize=22)\nplt.xlabel(\"Date\", fontsize=18)\nplt.ylabel(\"Normalized Close Price\", fontsize=18)\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=16)\nplt.legend(fontsize=18, frameon=False)\nplt.grid(axis='y', alpha=0.5)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nBad Example: Legendがunsortedのまま\n\n\n\n\n\n\n\n\n\nBetter Example: Legendがsortedされている\n\n\n\n\n\n\n\n凡例とシンボル\n\n\n\n\n\n\nRules\n\n\n\n\n色だけでなくてシンボルと組み合わせてクラスターの識別力を上げる\nmarker colorの区別が難しい場合は，色の順番を工夫すること\n\n\n\n\nCode\nimport seaborn as sns\nfrom sklearn.datasets import load_iris\nimport matplotlib.colors as mcolors\n\n# Function to lighten a hex color\ndef lighten_color(color, amount=0.5):\n    c = mcolors.to_rgb(color)\n    # linear interpolation towards white\n    lightened = [1 - amount * (1 - x) for x in c]\n    return lightened\n\n# Load iris dataset\niris = load_iris()\ndf = pd.DataFrame(iris.data, columns=iris.feature_names)\ndf['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\n# Okabe-Ito color palette (colorblind-friendly)\nokabe_ito = [\"#E69F00\", \"#56B4E9\", \"#009E73\"]\n\n# Set seaborn style\nsns.set(style=\"white\")\n\n# Create scatter plot\nplt.figure(figsize=(12, 8))\nsns.scatterplot(\n    data=df,\n    x='sepal length (cm)',\n    y='sepal width (cm)',\n    hue='species',\n    style='species',\n    palette=okabe_ito,\n    s=160,  # marker size\n    edgecolor='w',  # white edge to markers\n    linewidth=1,\n)\n\n# Axis labels\nplt.xlabel('sepal length')\nplt.ylabel('sepal width')\n\n# Legend style: italic labels\nleg = plt.legend()\nfor text in leg.get_texts():\n    text.set_fontstyle('italic')\n\nplt.tight_layout()\nplt.show()\n\n\n# Okabe-Ito color palette (colorblind-friendly)\nokabe_ito2 = [\"#56B4E9\", \"#E69F00\", \"#009E73\"]\n\n# Markers for species: circle, square, diamond (angled square)\nmarkers = ['o', 's', 'D']\n\n# Set seaborn style\nsns.set(style=\"whitegrid\")\n\n# Create scatter plot\nplt.figure(figsize=(12, 8))\n# Plot each species separately\nfor i, species in enumerate(df['species'].cat.categories):\n    data = df[df['species'] == species]\n    edge_col = okabe_ito2[i]\n    face_col = lighten_color(edge_col, amount=0.8)  # lighter fill\n    plt.scatter(\n        data['sepal length (cm)'],\n        data['sepal width (cm)'],\n        label=species,\n        marker=markers[i],\n        s=110,\n        edgecolor=edge_col,\n        facecolor=(*face_col, 0.5) ,\n        linewidth=0.8,\n    )\n\nplt.xlabel('sepal length', fontsize=18)\nplt.ylabel('sepal width', fontsize=18)\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=16)\n\n# Legend outside plot on the right\nleg = plt.legend(\n    fontsize=16, \n    loc='center left',       # legend location relative to bbox_to_anchor\n    bbox_to_anchor=(1, 0.5), # x=1 means just outside right edge, y=0.5 is vertical center\n    borderaxespad=0.5,\n    frameon=False,\n    handlelength=3,     # longer marker in legend\n    handletextpad=0.05,  # more space between marker and text\n    labelspacing=1.2    # more vertical spacing between items\n)\n\n# remove box\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\nDefault Cluter plot\n\n\n\n\n\n\n\n\n\nImproved Cluster plot\n\n\n\n\n\n\n\n凡例のタイトル\n\n\n\n\n\n\nRules\n\n\n\n\n凡例タイトルは必ずしも必要ではない\n含める場合には，「凡例」や「キー」といった一般的なタイトルを使うのではなく，ラベル付けされたデータの意味を伝えるタイトルを使うこと\n\n\n\n\n\n凡例は本当に必要なのか？\n\n\n\n\n\n\nRules\n\n\n\n\n凡例がなくて済むなら，凡例は用いないこと\n明示的な凡例がなくても，各可視化要素が何を意味しているのかが一目でわかるようにする\n\n\n\n凡例があると，可視化オブジェクトの読み手は，「１回目線を凡例に向けてから，再びline plotに目線を向けて各線を解釈する」というメンタルワークを結果的に強いられることになります．可視化オブジェクトが凡例なしで済むならば，このような理解の手間を減らすことができます．\nこの設計の実現手段として「Direct Labeling」があります．\n\nDefinition 3.2 Direct Labeling\n図の中に適切なテキストラベルや他の視覚的ガイド要素を直接配置する手法\n\n\n\nCode\n# プロット\nplt.figure(figsize=(12, 8))\nfor c_index, col in enumerate(sorted_columns):\n    plt.plot(df_all.index, df_all[col], label=col, color=okabe_ito_colors[c_index])\n    \n    # direct label を末尾に追加\n    y_pos = df_all[col].iloc[-1]\n    plt.text(df_all.index[-1], y_pos, f\" {col}\", color=\"#1A1A1A\",\n             va='center', fontsize=20)\n\n# remove box\nfor spine in plt.gca().spines.values():\n    spine.set_visible(False)\n\nplt.title(\"Normalized Stock Prices (Base=100 at 2020-01)\", fontsize=22)\nplt.xlabel(\"Date\", fontsize=18)\nplt.ylabel(\"Normalized Close Price\", fontsize=18)\nplt.xticks(fontsize=14)\nplt.yticks(fontsize=16) \nplt.grid(axis='y', alpha=0.5)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nDensity Plot without Legends\n\ntext label colorが明るすぎると，ラベルの読みづらくなるので，色の対応をキープする範囲内で暗い色にする\n\n\n\nCode\nfrom cmap import Colormap\nimport numpy as np\n\ndef darken_color(rgb, amount=0.7):\n    # rgb is tuple (r, g, b, a), scale RGB channels by amount (0 &lt; amount &lt; 1)\n    r, g, b, a = rgb\n    r, g, b = np.array([r, g, b]) * amount\n    return (r, g, b, a)\n\n\n# Iris データセットをロード\niris = load_iris()\ndf = pd.DataFrame(data=iris.data, columns=iris.feature_names)\ndf['species'] = pd.Categorical.from_codes(iris.target, iris.target_names)\n\n# カラーマップ（手動でセット）\ncm = Colormap('okabeito:okabeito')  # case insensitive\nmpl_cmap = cm.to_mpl()\ncolors = [mpl_cmap(i) for i in np.linspace(0, 1, 5)][1:]\ndarker_colors = [darken_color(c, amount=0.5) for c in colors]\n\npalette = dict(zip(df['species'].cat.categories, colors))\n\n# Set Seaborn style\nsns.set(style=\"white\")\n\n# カーネル密度推定プロット\nplt.figure(figsize=(12, 8))\nsns.kdeplot(\n    data=df,\n    x=\"sepal length (cm)\",\n    hue=\"species\",\n    fill=True,\n    common_norm=False,\n    palette=palette,\n    alpha=0.5,\n    linewidth=2.5\n)\n\n# ラベルのスタイル\nplt.text(5.2, 1.1, \"Iris setosa\", color=darker_colors[0], fontsize=18, style='italic')\nplt.text(5.5, 0.75, \"Iris versicolor\", color=darker_colors[1], fontsize=18, style='italic')\nplt.text(6.5, 0.65, \"Iris virginica\", color=darker_colors[2], fontsize=18, style='italic')\n\n# 軸ラベルと体裁\nplt.xlabel(\"sepal length\", fontsize=18)\nplt.ylabel(\"density\", fontsize=18)\nplt.xticks(fontsize=16)\nplt.yticks(fontsize=16)\nplt.legend([],[], frameon=False)  # 凡例を削除\nsns.despine()  # 枠線を削除\nplt.tight_layout()\nplt.grid(axis='y', alpha=0.5)\nplt.show()",
    "crumbs": [
      "可視化オブジェクトのComponents",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Legends(凡例)</span>"
    ]
  },
  {
    "objectID": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html",
    "href": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html",
    "title": "4  質的データの出現頻度",
    "section": "",
    "text": "問題設定\n以下のようなカテゴリ別出現頻度のデータが与えられたとします．\nCode\nimport pandas as pd\n\n\ndata = {\n    \"faulty_component\": [\n        \"ハードディスク\", \"ハードディスク\",\n        \"メモリ\", \"メモリ\",\n        \"電源ユニット\", \"電源ユニット\",\n        \"ファン\", \"マザーボード\",\n        \"液晶ディスプレイ\", \"液晶ディスプレイ\",\n        \"ソフトウェア\", \"ソフトウェア\"\n    ],\n    \"faulty_category\": [\n        \"接続不良\", \"異音\",\n        \"起動不良\", \"ブルースクリーン\",\n        \"電源不安定\", \"電源不良\",\n        \"異音\", \"接続不良\",\n        \"画面不認識\", \"表示トラブル\",\n        \"起動時エラー\", \"アプリ強制終了\"\n    ],\n    \"count\": [125, 87, 73, 52, 64, 91, 40, 38, 70, 33, 49, 58]\n}\n\ndf = pd.DataFrame(data)\ndf\n\n\n\n\n\n\n\n\n\nfaulty_component\nfaulty_category\ncount\n\n\n\n\n0\nハードディスク\n接続不良\n125\n\n\n1\nハードディスク\n異音\n87\n\n\n2\nメモリ\n起動不良\n73\n\n\n3\nメモリ\nブルースクリーン\n52\n\n\n4\n電源ユニット\n電源不安定\n64\n\n\n5\n電源ユニット\n電源不良\n91\n\n\n6\nファン\n異音\n40\n\n\n7\nマザーボード\n接続不良\n38\n\n\n8\n液晶ディスプレイ\n画面不認識\n70\n\n\n9\n液晶ディスプレイ\n表示トラブル\n33\n\n\n10\nソフトウェア\n起動時エラー\n49\n\n\n11\nソフトウェア\nアプリ強制終了\n58",
    "crumbs": [
      "1次元データ",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>質的データの出現頻度</span>"
    ]
  },
  {
    "objectID": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#問題設定",
    "href": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#問題設定",
    "title": "4  質的データの出現頻度",
    "section": "",
    "text": "faulty_component: 故障箇所\nfaulty_category: 故障内容に応じた分類\ncount: 出現頻度\n\n\n\n可視化方針\n\n\n\n\n\n\n要件\n\n\n\n\n\n複数カテゴリ変数を結合して生成したラベル変数をkey，出現頻度をvalueとしたデータについて，出現頻度をbar plot, 累積頻度をline plotとして可視化\n2つのカテゴリ次元にわたる値の頻度分布をheatmapを用いて可視化\n\n\n\n\n以上の２つを可視化実装を取り扱いますが，実装説明の前にEDAとしてどのようなstory-tellingが考えられるか紹介します．\n\n\n\n\n\n\n\nパレート図分析summary例\n\n\n\n\n\n\nExample 4.1 \n\n\n\n\n\n\n\n分析テーマ\n無数にあるように見える故障のうち，実際に対応すべきはごく一部の代表的なパターンなのではないか？\n\n\n可視化解釈\nカテゴリ組み合わせは無数にあるが，Top 10だけでも異常発生件数全体の 80%をしめており，Top 10のみに集中してアクションをとるべき\n\n\nインサイト\nリソースを広く分散するのではなく，「ファン-動作不良」「HDD-認識不能」など，頻度の高いカテゴリに絞って改善策・品質対策・部品見直し・製造工程チェックを行うことが，最もコストパフォーマンスの高い改善になる\n\n\n\n\n\n\nExample 4.2 \n\n\n\n\n\n\n\n分析テーマ\n故障カテゴリの問題があるため故障頻度分布は裾の厚い分布担っているのではないか？\n\n\n可視化解釈\nカテゴリ組み合わせTop 10に絞っても累積故障割合は全体の40%を占めるにとどまっており，故障カテゴリは裾の厚い(fat-tailed)分布と見える．故障カテゴリ分類について一部粒度が細かすぎるため裾が厚くなってしまったと仮説立て，補修アクションの観点を踏まえてカテゴリを再定義した上で集計し直したところ，Top10カテゴリで全体の約75%をカバーする構造が浮かび上がった．(=fat-tailed 分布の見え方は，分類設計そのものの歪みを示している可能性がある)\n\n\nインサイト\n故障ログの分類設計には，実際のオペレーションや対応フローとの整合性を持たせることが重要再定義したカテゴリを標準分類とし，継続的な分析に活用できるよう設計を整備する必要性あり\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nheatmap分析summary例\n\n\n\n\n\n\nExample 4.3 \n\n\n\n\n\n\n\n分析テーマ\n故障箇所 × 故障内容の組み合わせ頻度に偏りが存在するかを確認し，重点対応すべきカテゴリを特定する\n\n\n可視化解釈\n故障箇所と故障内容の組み合わせを2軸にとったヒートマップを作成したところ，特定のパターンに件数が極端に集中している構造が明らかになったたとえば，「HDD × 認識不能」や「ファン × 動作不良」といった一部の組み合わせセルが強調され，その他多くのセルが極端に件数の少ない状態であることから，故障パターンが限定的であることが視覚的に示された\n\n\nインサイト\n故障は一見バラバラに発生しているようでいて，実際には限られた数の典型的パターンに集中的に発生している\n\n\n\n\n\n\nExample 4.4 \n\n\n\n\n\n\n\n分析テーマ\n故障箇所 × 故障内容の組み合わせの中で，一見目立たないが相対的に異常頻度が高い“隠れホットスポット”を可視化する\n\n\n可視化解釈\n故障ログ全体をヒートマップで俯瞰した結果，全体件数では上位に入らないカテゴリの中にも，特定の故障内容に偏った異常発生が集中している箇所があることが明らかになった「電源ユニット × 異音」や「メモリ × 接触不良」など，ランキングでは目立たないものの，他の故障内容と比較すると明らかに“浮いている”セルが存在していた\n\n\nインサイト\n今後のモニタリングでは，件数が少なくても極端な偏りを示す“異常に濃いセル”をトリガーに，点検対象の見直しやアラート条件の再設計を検討すべき",
    "crumbs": [
      "1次元データ",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>質的データの出現頻度</span>"
    ]
  },
  {
    "objectID": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#可視化実装1-パレート図",
    "href": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#可視化実装1-パレート図",
    "title": "4  質的データの出現頻度",
    "section": "可視化実装1: パレート図",
    "text": "可視化実装1: パレート図\n ▶  前処理\n出現頻度のカラムを用いて事前に descending sort を以下のように実施します．\n\n\nCode\ndf_sorted = df.sort_values(by=\"count\", ascending=False).reset_index(drop=True)\ndf_sorted[\"cum_percent\"] = df_sorted[\"count\"].cumsum() / df_sorted[\"count\"].sum()\ndf_sorted[\"label\"] = df_sorted[\"faulty_component\"].astype(str) + \"-\" + df_sorted[\"faulty_category\"].astype(str)\ndf_sorted.head()\n\n\n\n\n\n\n\n\n\nfaulty_component\nfaulty_category\ncount\ncum_percent\nlabel\n\n\n\n\n0\nハードディスク\n接続不良\n125\n0.160256\nハードディスク-接続不良\n\n\n1\n電源ユニット\n電源不良\n91\n0.276923\n電源ユニット-電源不良\n\n\n2\nハードディスク\n異音\n87\n0.388462\nハードディスク-異音\n\n\n3\nメモリ\n起動不良\n73\n0.482051\nメモリ-起動不良\n\n\n4\n液晶ディスプレイ\n画面不認識\n70\n0.571795\n液晶ディスプレイ-画面不認識\n\n\n\n\n\n\n\n  ▶  引数テーブル\n\nArgs\n\n\n\n\n\n\n引数\n説明\n\n\n\n\ndata\nカテゴリ，件数，累積値を含む入力データ．cumulative plotが正しく動作するには，データが適切にソートされている必要がある\n\n\ncategory_column\nx軸に使用するカテゴリ列の名前\n\n\ncount_column\n棒グラフ（主軸）に使用する件数列の名前\n\n\ncumulative_column\nline plot(y2-axis)に使用する累積値（例：パーセンテージ）の列の名前\n\n\nxaxis_name\n: x軸のタイトル．デフォルトは \"\"\n\n\ny1_axis_name\ny1-axisのタイトル．デフォルトは \"\"\n\n\ny2_axis_name\ny2-axisのタイトル．デフォルトは \"\"\n\n\ny1_label\nbar plotのlegendラベル．デフォルトは \"\"\n\n\ny2_label\ncumulative plotのlegendラベル．デフォルトは \"\"\n\n\nfigure_title\n図全体のタイトル．デフォルトは \"\"\n\n\nfigsize\nmatplotlib用のfigure size設定値(tuple)\n\n\n\n  ▶  Plotly を用いた可視化\n\n\nCode\nimport plotly.graph_objects as go\n\n\ndef plot_category_frequency_plotly(\n    data: pd.DataFrame,\n    category_column: str,\n    count_column: str,\n    cumulative_column: str,\n    xaxis_name: str = \"\",\n    y1_axis_name: str = \"\",\n    y2_axis_name: str = \"\",\n    y1_label: str = \"\",\n    y2_label: str = \"\",\n    figure_title: str = \"\",\n) -&gt; go.Figure:\n    \"\"\"\n    - カテゴリごとの件数を棒グラフで，累積値（例：累積パーセンテージ）を折れ線グラフで可視化するPlotly図を生成\n    - cumulative plotが正しく動作するには，データが適切にソートされている必要がある\n    \"\"\"\n    # create bar trace\n    bar = go.Bar(\n        x=data[category_column],\n        y=data[count_column],\n        name=y1_label,\n        yaxis=\"y1\",\n        marker=dict(color=\"#6699CC\"),\n    )\n\n    # Create cumulative line trace\n    line = go.Scatter(\n        x=data[category_column],\n        y=data[cumulative_column],\n        name=y2_label,\n        yaxis=\"y2\",\n        mode=\"lines+markers\",\n        line=dict(color=\"#000000\", dash=\"dot\"),\n    )\n\n    # Layout\n    layout = go.Layout(\n        title=dict(\n            text=figure_title,\n            x=0.,\n            xanchor=\"left\",\n            yanchor=\"top\",\n        ),\n        margin=dict(t=50),\n        xaxis=dict(title=xaxis_name, tickangle=45),\n        yaxis=dict(title=y1_axis_name),\n        yaxis2=dict(\n            title=y2_axis_name,\n            overlaying=\"y\",\n            side=\"right\",\n            range=[0, 1.1],\n            gridcolor=\"#EFF5F5\",\n        ),\n        legend=dict(x=1.05, y=1.0, orientation=\"v\"),\n    )\n\n    # Plot\n    fig = go.Figure(data=[bar, line], layout=layout).update_layout(\n        {\"plot_bgcolor\": \"#EFF5F5\", \"yaxis\": {\"gridcolor\": \"#EFF5F5\"}}\n    )\n\n    return fig\n\n\n実行コードは以下，\n\n\nCode\nfig = plot_category_frequency_plotly(\n    data=df_sorted,\n    category_column=\"label\",\n    count_column=\"count\",\n    cumulative_column=\"cum_percent\",\n    xaxis_name=\"Faulty Category\",\n    y1_axis_name=\"Frequency\",\n    y2_axis_name=\"Cumulative Percentage\",\n    y1_label=\"件数\",\n    y2_label=\"累積割合\",\n    figure_title=\"PC Faulty component frequency\",\n)\nfig.show()\n\n\n                                                \n\n\n  ▶  matplotlib を用いた可視化\n\n\nCode\nimport matplotlib.pyplot as plt\n\n\ndef plot_category_frequency_matplotlib(\n    data: pd.DataFrame,\n    category_column: str,\n    count_column: str,\n    cumulative_column: str,\n    xaxis_name: str = \"\",\n    y1_axis_name: str = \"\",\n    y2_axis_name: str = \"\",\n    y1_label: str = \"\",\n    y2_label: str = \"\",\n    figure_title: str = \"\",\n    figsize: tuple = (8, 6),\n):\n    fig, ax1 = plt.subplots(figsize=figsize)\n    ax1.set_facecolor(\"#EFF5F5\")  # 👈 plot background color\n\n    # Bar plot on primary y-axis\n    bars = ax1.bar(\n        data[category_column], data[count_column], color=\"#6699CC\", label=y1_label\n    )\n    ax1.set_ylabel(y1_axis_name, fontsize=12)\n    ax1.set_xlabel(xaxis_name, fontsize=12)\n    ax1.tick_params(axis=\"y\")\n\n    # Line plot on secondary y-axis\n    ax2 = ax1.twinx()\n    line = ax2.plot(\n        data[category_column],\n        data[cumulative_column],\n        color=\"#000000\",\n        linestyle=\"dotted\",\n        marker=\"o\",\n        label=y2_label,\n    )\n    ax2.set_ylabel(y2_axis_name, fontsize=12)\n    ax2.set_ylim(0, 1.1)\n    ax2.tick_params(axis=\"y\")\n    plt.setp(ax1.get_xticklabels(), rotation=(360-45), ha=\"left\")  # 👈 Rotate x-axis labels\n    \n    # Title and legend\n    fig.suptitle(figure_title, x=0.0, ha=\"left\", fontsize=14)\n\n    # Combine legends from both axes\n    lines_labels = [*ax1.get_legend_handles_labels(), *ax2.get_legend_handles_labels()]\n    fig.legend(loc=\"upper left\", bbox_to_anchor=(0.925, 0.925))\n    fig.patch.set_facecolor(\"#FFFFFF\")\n\n    plt.tight_layout()\n    return fig, ax1, ax2\n\n\n実行コードは以下，\n\n\nCode\nfrom regmonkey_style import stylewizard as sw\n\n# japanese language setup\nsw.set_font(\"IPAexGothic\")\n\n\nfig, ax1, ax2 = plot_category_frequency_matplotlib(\n    data=df_sorted,\n    category_column=\"label\",\n    count_column=\"count\",\n    cumulative_column=\"cum_percent\",\n    xaxis_name=\"Faulty Category\",\n    y1_axis_name=\"Frequency\",\n    y2_axis_name=\"Cumulative Percentage\",\n    y1_label=\"件数\",\n    y2_label=\"累積割合\",\n    figure_title=\"PC Faulty component frequency\",\n)\nplt.show()",
    "crumbs": [
      "1次元データ",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>質的データの出現頻度</span>"
    ]
  },
  {
    "objectID": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#可視化実装2-heatmap",
    "href": "posts/1D-datavisualization/frequency-counts-of-data-with-bar-plot.html#可視化実装2-heatmap",
    "title": "4  質的データの出現頻度",
    "section": "可視化実装2: heatmap",
    "text": "可視化実装2: heatmap\n\nここでは，xaxis, yaxisとなる２つのカテゴリ変数を用いてpivot tableを作成し，それをheatmapで可視化\npivotにあたっての集計関数は sum を用いる\nNaN（欠損値）はプロット前に0で補完\n\"PuBu\" カラースケールを使用\n\n ▶  実装\n\n\nCode\nimport seaborn as sns\n\n\ndef heatmap_frequency(\n    data: pd.DataFrame,\n    xaxis_column: str,\n    yaxis_column: str,\n    value_column: str,\n    x_axis_name: str = \"\",\n    y_axis_name: str = \"\",\n    figure_title: str = \"\",\n    plot_type = 'plotly',\n    figsize = (10, 6)\n):\n    table = pd.pivot_table(\n        data,\n        values=value_column,\n        index=[yaxis_column],\n        columns=[xaxis_column],\n        aggfunc=\"sum\",\n    ).fillna(0)\n\n    if plot_type == 'plotly':\n        fig = go.Figure(\n            data=go.Heatmap(\n                z=table.values,\n                x=table.columns,  # Optional: x-axis labels\n                y=table.index,  # Optional: y-axis labels\n                colorscale=\"PuBu\",  # You can try: 'Blues', 'Hot', 'Cividis', etc.\n            )\n        )\n\n        fig.update_layout(\n            title=figure_title, xaxis_title=x_axis_name, yaxis_title=y_axis_name\n            \n        )\n\n        return fig\n    \n    else:\n         # Create the plot\n        fig, ax = plt.subplots(figsize=figsize)\n\n        sns.heatmap(\n            table.values,\n            xticklabels=table.columns,\n            yticklabels=table.index,\n            cmap=\"PuBu\",\n            ax=ax\n        )\n\n        ax.set_xlabel(x_axis_name)\n        ax.set_ylabel(y_axis_name)\n        ax.set_title(figure_title, loc=\"center\")\n\n        plt.xticks(rotation=(360-45), ha='left')\n        plt.yticks(rotation=0)\n\n        plt.tight_layout()\n        return fig, ax\n\n\n ▶  Plotly による可視化\n\n\nCode\nfig = heatmap_frequency(\n    data=df_sorted,\n    xaxis_column=\"faulty_category\",\n    yaxis_column=\"faulty_component\",\n    value_column=\"count\",\n    x_axis_name=\"故障カテゴリ\",\n    y_axis_name=\"故障箇所\",\n    figure_title=dict(\n        text=\"故障分布\",\n        font=dict(size=18),\n        automargin=True,\n        x=0.5,  # Center title\n        y=0.95,\n        xanchor=\"center\",\n    ),\n)\n\n\nfig.show()\n\n\n                                                \n\n\n ▶  matplotlib による可視化\n\n\nCode\nfig, ax = heatmap_frequency(\n    data=df_sorted,\n    xaxis_column='faulty_category',\n    yaxis_column='faulty_component',\n    value_column='count',\n    x_axis_name='故障カテゴリ',\n    y_axis_name='故障箇所',\n    figure_title='故障分布',\n    plot_type = 'matplotlib',\n)\n\nplt.show()",
    "crumbs": [
      "1次元データ",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>質的データの出現頻度</span>"
    ]
  },
  {
    "objectID": "posts/relationships-between-variables/chapter-header.html",
    "href": "posts/relationships-between-variables/chapter-header.html",
    "title": "変数間の関係性",
    "section": "",
    "text": "変数間の関係性: correlationとconnection\n\\(p\\) 次元データを取り扱う場合，\nというEDAクエッションを明らかにしたいケースが多いと思います．変数感の関係性は一般に 変数間の相関(correlation) という観点でをfirst stepの可視化が試みられます． 具体的には選択した２変数のscatter plotやline plotでの可視化となります．ここでいう「変数間の相関」はPearson相関係数のみを指すのではなく，\nという幅広い概念です．また，変数間の関係性は相関だけでなく，個々のdata pointsがどのようにリンクしているのか？という 変数感のつながり(connection) の可視化も試みられたりします． 具体的にはネットワークグラフの可視化などが該当します．",
    "crumbs": [
      "変数間の関係性"
    ]
  },
  {
    "objectID": "posts/relationships-between-variables/chapter-header.html#変数間の関係性-correlationとconnection",
    "href": "posts/relationships-between-variables/chapter-header.html#変数間の関係性-correlationとconnection",
    "title": "変数間の関係性",
    "section": "",
    "text": "Definition 1 : 多次元データ \n単一の変数 \\(x\\) だけでなく，\\((x, y, z)\\) などの複数の変数を観測して，\\(n\\) 組のデータを得る場合，そのデータを多次元データと呼ぶ． 一般に \\(p\\) 個の変数を取り扱う場合．\\(p\\) 次元データと呼ぶ．\n\n\n\n\n変数感の関係性(relation, relationship)はどのようになっているのか？\n一方が増えたら他方も増えるような関係性になっているのか？\n\n\n\n一方の変数が変化したとき，もう一方の変数の変化はどのような傾向があるのか？",
    "crumbs": [
      "変数間の関係性"
    ]
  },
  {
    "objectID": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html",
    "href": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html",
    "title": "5  グループ間の割合差分",
    "section": "",
    "text": "問題設定\nData\nCode\nimport pandas as pd\n\ndata = {\n    '2024': [0.72, 0.10, 0.05, 0.03, 0.02, 0.03, 0.015, 0.01], # 'Public transportation'はn/aのためNaN\n    '2019': [0.85, 0.12, 0.09, 0.06, 0.05, 0.04, 0.03, 0.02]\n}\n\nindex = [\n    'Own car',\n    'Public transportation',\n    'Walking',\n    'Own bike',\n    'Ride hailing',\n    'Car sharing',\n    'Taxi',\n    'Motorcycle'\n]\n\ndf = pd.DataFrame(data, index=index).sort_values(by='2024')\ndf\n\n\n\n\nTable 5.1: U.S. modes of tranportation to commute\n\n\n\n\n\n\n\n\n\n\n2024\n2019\n\n\n\n\nMotorcycle\n0.010\n0.02\n\n\nTaxi\n0.015\n0.03\n\n\nRide hailing\n0.020\n0.05\n\n\nOwn bike\n0.030\n0.06\n\n\nCar sharing\n0.030\n0.04\n\n\nWalking\n0.050\n0.09\n\n\nPublic transportation\n0.100\n0.12\n\n\nOwn car\n0.720\n0.85\nKey message",
    "crumbs": [
      "グループ間の比較",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>グループ間の割合差分</span>"
    ]
  },
  {
    "objectID": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#問題設定",
    "href": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#問題設定",
    "title": "5  グループ間の割合差分",
    "section": "",
    "text": "2020コロナ流行という生活スタイル激変イベントがあったにも関わらず、人々の日常交通手段は依然として車が中心的",
    "crumbs": [
      "グループ間の比較",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>グループ間の割合差分</span>"
    ]
  },
  {
    "objectID": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#可視化方針",
    "href": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#可視化方針",
    "title": "5  グループ間の割合差分",
    "section": "可視化方針",
    "text": "可視化方針\n\n\n\n\n\n\nObjectives\n\n\n\n\n\n2019年と2024年の2つの時点における交通手段の利用状況（利用割合）を車利用者割合2019 vs 車利用者割合2024というApple-to-Appleで比較しやすくする\n時間の経過とともに各交通手段の利用率がどのように変化したかを把握しやすくしたい\n\n\n\n\n\n方針検討\n\n移動手段というカテゴリカルデータ(value同士に順序性はない)\n人間の目は左上からz文字の順番で情報を処理する傾向がある\n自家所有者(Own car)を左に見てから，目線が右に移動し，2019 vs 2024で比較するのが自然な流れ(=数値水準を確認する前にその数値がどのカテゴリーのものなのかを自然な流れで見てもらえる)\n2019年と2024年ともに自家用車がメインの交通手段であることを伝えたいので，カテゴリーは2019年の利用割合でソートする\n\n\n\n\n\n\n\nREMARKS\n\n\n\n\n\nカテゴリカル別水準を示したいときはhorizontal bar chartが効果的\n読みやすさ or メッセージと整合的な形でカテゴリーをソートする",
    "crumbs": [
      "グループ間の比較",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>グループ間の割合差分</span>"
    ]
  },
  {
    "objectID": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#可視化実装",
    "href": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#可視化実装",
    "title": "5  グループ間の割合差分",
    "section": "可視化実装",
    "text": "可視化実装\n\n(A) Plotly with horizontal bar plot\n\n\nCode\nimport plotly.graph_objects as go\n\nfig = go.Figure()\n\n# Add bars for 2024/2025\nfig.add_trace(\n    go.Bar(\n        y=df.index,\n        x=df[\"2024\"],\n        legendgroup=\"group\",\n        legendgrouptitle_text=\"year\",\n        name=\"2024\",\n        orientation=\"h\",\n        marker_color=\"#003366\",\n    )\n)\n\n# Add bars for 2019\nfig.add_trace(\n    go.Bar(\n        y=df.index,\n        x=df[\"2019\"],\n        legendgroup=\"group\",\n        legendgrouptitle_text=\"year\",\n        name=\"2019\",\n        orientation=\"h\",\n        marker_color=\"#99ccff\",\n    )\n)\n\n\n# Layout customization\nfig.update_layout(\n    title=dict(\n        text=\"2020年コロナ流行後も人々の日常交通手段は依然として車が中心的\",\n        font=dict(size=21),\n    ),\n    xaxis=dict(\n        title=\"Share of commuters\",\n        tickformat=\".0%\",  # Format as percentage\n        tickfont=dict(size=16),\n        range=[0, 1.0],\n        gridcolor=\"#DEDEDE\",\n    ),\n    yaxis=dict(\n        tickfont=dict(size=16),\n        automargin=True,  # helps avoid label clipping\n    ),\n    barmode=\"group\",  # you can also try 'group' for grouped layout\n    height=600,\n    bargroupgap=0,\n    legend=dict(orientation=\"h\", yanchor=\"bottom\", y=0.1, xanchor=\"right\", x=0.95),\n    plot_bgcolor=\"#EFF5F5\",\n)\n\nfig.add_annotation(\n    text=\"Source: Statista Consumer Insights, 3,338(2019) and 7,447(2024) U.S. respondents (18-64 y/o)\",\n    xref=\"paper\",\n    yref=\"paper\",\n    x=-0.15,\n    y=-0.2,  # y &lt; 0 puts it below the chart\n    showarrow=False,\n    font=dict(size=14, color=\"gray\"),\n    xanchor=\"left\",\n)\n\nfig.update_layout(\n    margin=dict(t=40, b=100)  # increase bottom margin\n)\n\nfig.show()\n\n\n                                                \n\n\n\n\n(B) Matplotlib with horizontal bar plot\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom regmonkey_style import stylewizard as sw\n\n# japanese language setup\nsw.set_font(\"IPAexGothic\")\n\n# Set figure size and style\nfig, ax = plt.subplots(figsize=(12, 10))\n\n# Create horizontal bars\ny_pos = np.arange(len(df.index))\nwidth = 0.35\n\n# Plot bars for 2024 and 2019\nbar1 = ax.barh(y_pos + width / 2, df[\"2019\"], width, label=\"2019\", color=\"#99ccff\")\nbar2 = ax.barh(y_pos - width / 2, df[\"2024\"], width, label=\"2024\", color=\"#003366\")\n\n# Customize axes\nax.set_yticks(y_pos)\nax.set_yticklabels(df.index, fontsize=16)\nax.set_xlabel(\"Share of commuters\", fontsize=16)\ntitle = ax.set_title(\n    \"2020コロナ流行後も人々の日常交通手段は依然として車が中心的\",\n    loc=\"left\",\n    pad=20,\n    fontsize=21,\n)\ntitle.set_position((-0.1, title.get_position()[1]))\n\n# Format x-axis as percentage\nax.set_xlim(0, 1.0)\nax.xaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: \"{:.0%}\".format(x)))\nax.tick_params(axis=\"x\", labelsize=16)\n\n# Customize grid\nax.grid(axis=\"x\", color=\"#DEDEDE\")\nax.set_facecolor(\"#EFF5F5\")\n\n# Add legend\nax.legend(loc=\"lower right\", bbox_to_anchor=(0.95, 0.1), ncol=2)\n\n# Add source annotation\nfig.text(\n    0,\n    0.1,\n    \"Source: Statista Consumer Insights, 3,338(2019) and 7,447(2024) U.S. respondents (18-64 y/o)\",\n    fontsize=12,\n    color=\"gray\",\n    ha=\"left\",\n)\n\n# Adjust layout to prevent clipping\nplt.subplots_adjust(bottom=0.2)\n\nplt.show()",
    "crumbs": [
      "グループ間の比較",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>グループ間の割合差分</span>"
    ]
  },
  {
    "objectID": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#references",
    "href": "posts/comparison-of-groups/categorical-group-ratios-with-stacked-bar-plot.html#references",
    "title": "5  グループ間の割合差分",
    "section": "References",
    "text": "References\n\nKnaflic (2016), p57-58\n\n\n\n\n\nKnaflic, C. N. (2016), Storytelling with Data: A Data Visualization Guide for Business Professionals, O’Reilly Media.",
    "crumbs": [
      "グループ間の比較",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>グループ間の割合差分</span>"
    ]
  }
]